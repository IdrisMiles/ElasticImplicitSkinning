\hypertarget{namespaceisgw}{}\section{isgw Namespace Reference}
\label{namespaceisgw}\index{isgw@{isgw}}


, Implicit Skin G\+PU Wrapper (isgw), wraps up Implicit Skinining C\+U\+DA kernals in a C\+PP interface  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint \hyperlink{namespaceisgw_a2e4ac5beae0fbbe25749f7ba5a85805e}{i\+Div\+Up} (uint a, uint b)
\begin{DoxyCompactList}\small\item\em Function to divide a by b and add 1 if there is a remainder, useful for generatinig the number of C\+U\+DA blocks from size of data and number of threads. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_a9f9396298bae07477376b8fa48795327}{Linear\+Blend\+Weight\+Skin} (glm\+::vec3 $\ast$\+\_\+deformed\+Vert, const glm\+::vec3 $\ast$\+\_\+orig\+Vert, glm\+::vec3 $\ast$\+\_\+deformed\+Norms, const glm\+::vec3 $\ast$\+\_\+orig\+Norms, const glm\+::mat4 $\ast$\+\_\+transform, const uint $\ast$\+\_\+bone\+Id, const float $\ast$\+\_\+weight, const int \+\_\+num\+Verts, const int \+\_\+num\+Bones)
\begin{DoxyCompactList}\small\item\em Function to launch C\+U\+DA Kernel to perform linear blend weight skinning. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_acd11ec618e357fefdc8e530211339cdf}{Simple\+Implicit\+Skin} (glm\+::vec3 $\ast$\+\_\+deformed\+Vert, const glm\+::vec3 $\ast$\+\_\+normal, const float $\ast$\+\_\+orig\+Iso\+Value, glm\+::vec3 $\ast$\+\_\+prev\+Iso\+Grad, const int \+\_\+num\+Verts, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const \hyperlink{classComposedFieldCuda}{Composed\+Field\+Cuda} $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields, const int $\ast$\+\_\+one\+Ring\+Verts, const float $\ast$\+\_\+centroid\+Weights, const int $\ast$\+\_\+neigh\+Scatter\+Addr, const float \+\_\+sigma, const float \+\_\+contact\+Angle, const int \+\_\+iterations)
\begin{DoxyCompactList}\small\item\em Function to launch C\+U\+DA Kernel to perform implicit skinning. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_a8eed7cf9e253eaf6b3e9651fdc3deb28}{Eval\+Global\+Field} (float $\ast$\+\_\+output, const glm\+::vec3 $\ast$\+\_\+sample\+Point, const int \+\_\+num\+Samples, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const \hyperlink{classComposedFieldCuda}{Composed\+Field\+Cuda} $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields)
\begin{DoxyCompactList}\small\item\em Function to launch C\+U\+DA Kernel to evaluate the global field. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_ad3f1a323ddd56e99eea0afe0d7fd42f0}{Eval\+Grad\+Global\+Field} (float $\ast$\+\_\+output, glm\+::vec3 $\ast$\+\_\+outputG, const glm\+::vec3 $\ast$\+\_\+sample\+Point, const int \+\_\+num\+Samples, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const \hyperlink{classComposedFieldCuda}{Composed\+Field\+Cuda} $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields)
\begin{DoxyCompactList}\small\item\em Function to launch C\+U\+DA Kernel to evaluate gradient of global field. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_a267fc0628a2245c86afb303701f45ddc}{Generate\+Scatter\+Address} (int $\ast$begin, int $\ast$end, int $\ast$scattered\+Addr)\hypertarget{namespaceisgw_a267fc0628a2245c86afb303701f45ddc}{}\label{namespaceisgw_a267fc0628a2245c86afb303701f45ddc}

\begin{DoxyCompactList}\small\item\em Method to generate scatter address, runs an exclusive scan. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_a89743f193a8a8203e343479029570309}{Generate\+One\+Ring\+Centroid\+Weights} (glm\+::vec3 $\ast$\+\_\+verts, const glm\+::vec3 $\ast$\+\_\+normals, const int \+\_\+num\+Verts, float $\ast$\+\_\+centroid\+Weights, const int $\ast$\+\_\+one\+Ring\+Ids, const glm\+::vec3 $\ast$\+\_\+one\+Ring\+Verts, const int $\ast$\+\_\+num\+Neighs\+Per\+Vert, const int $\ast$\+\_\+one\+Ring\+Scatter\+Addr)
\begin{DoxyCompactList}\small\item\em Method to generate the one ring centroid weights for each mesh vertex using Mean Value Coordinates method. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
, Implicit Skin G\+PU Wrapper (isgw), wraps up Implicit Skinining C\+U\+DA kernals in a C\+PP interface 

\begin{DoxyAuthor}{Author}
Idris Miles 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0  18/04/2017 
\end{DoxyVersion}


\subsection{Function Documentation}
\index{isgw@{isgw}!Eval\+Global\+Field@{Eval\+Global\+Field}}
\index{Eval\+Global\+Field@{Eval\+Global\+Field}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{Eval\+Global\+Field(float $\ast$\+\_\+output, const glm\+::vec3 $\ast$\+\_\+sample\+Point, const int \+\_\+num\+Samples, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const Composed\+Field\+Cuda $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields)}{EvalGlobalField(float *_output, const glm::vec3 *_samplePoint, const int _numSamples, const glm::mat4 *_textureSpace, const glm::mat4 *_rigidTransforms, const cudaTextureObject_t *_fieldFuncs, const int _numFields, const cudaTextureObject_t *_compOps, const cudaTextureObject_t *_theta, const int _numOps, const ComposedFieldCuda *_compFields, const int _numCompFields)}}]{\setlength{\rightskip}{0pt plus 5cm}void isgw\+::\+Eval\+Global\+Field (
\begin{DoxyParamCaption}
\item[{float $\ast$}]{\+\_\+output, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+sample\+Point, }
\item[{const int}]{\+\_\+num\+Samples, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+texture\+Space, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+rigid\+Transforms, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+field\+Funcs, }
\item[{const int}]{\+\_\+num\+Fields, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+comp\+Ops, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+theta, }
\item[{const int}]{\+\_\+num\+Ops, }
\item[{const {\bf Composed\+Field\+Cuda} $\ast$}]{\+\_\+comp\+Fields, }
\item[{const int}]{\+\_\+num\+Comp\+Fields}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_a8eed7cf9e253eaf6b3e9651fdc3deb28}{}\label{namespaceisgw_a8eed7cf9e253eaf6b3e9651fdc3deb28}


Function to launch C\+U\+DA Kernel to evaluate the global field. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+output} & \+: Device pointer to the output \\
\hline
{\em \+\_\+sample\+Point} & \+: Const device pointer to the sample points \\
\hline
{\em \+\_\+num\+Samples} & The number of samples \\
\hline
{\em \+\_\+texture\+Space} & \+: Const device pointer to the texture space transform matrices, transform world space to texture space \\
\hline
{\em \+\_\+rigid\+Transform} & \+: Const device pointer to the rigid bone transform matrices \\
\hline
{\em \+\_\+field\+Funcs} & \+: Const device pointer to an array of textures holding the individual field functions \\
\hline
{\em \+\_\+num\+Fields} & \+: The number of field function textures \\
\hline
{\em \+\_\+comp\+Ops} & \+: Device pointer to to composition operator 3D textures. \\
\hline
{\em \+\_\+theta} & \+: Device pointer to theta opening function 1D texture. \\
\hline
{\em \+\_\+num\+Ops} & \+: Number of composition operators. \\
\hline
{\em \+\_\+comp\+Fields} & \+: Device pointer to composed fields, a structure that holds ids for primitive fields and their composition operator \\
\hline
{\em \+\_\+num\+Comp\+Fields} & \+: Number of composed fields \\
\hline
\end{DoxyParams}
\index{isgw@{isgw}!Eval\+Grad\+Global\+Field@{Eval\+Grad\+Global\+Field}}
\index{Eval\+Grad\+Global\+Field@{Eval\+Grad\+Global\+Field}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{Eval\+Grad\+Global\+Field(float $\ast$\+\_\+output, glm\+::vec3 $\ast$\+\_\+output\+G, const glm\+::vec3 $\ast$\+\_\+sample\+Point, const int \+\_\+num\+Samples, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const Composed\+Field\+Cuda $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields)}{EvalGradGlobalField(float *_output, glm::vec3 *_outputG, const glm::vec3 *_samplePoint, const int _numSamples, const glm::mat4 *_textureSpace, const glm::mat4 *_rigidTransforms, const cudaTextureObject_t *_fieldFuncs, const int _numFields, const cudaTextureObject_t *_compOps, const cudaTextureObject_t *_theta, const int _numOps, const ComposedFieldCuda *_compFields, const int _numCompFields)}}]{\setlength{\rightskip}{0pt plus 5cm}void isgw\+::\+Eval\+Grad\+Global\+Field (
\begin{DoxyParamCaption}
\item[{float $\ast$}]{\+\_\+output, }
\item[{glm\+::vec3 $\ast$}]{\+\_\+outputG, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+sample\+Point, }
\item[{const int}]{\+\_\+num\+Samples, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+texture\+Space, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+rigid\+Transforms, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+field\+Funcs, }
\item[{const int}]{\+\_\+num\+Fields, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+comp\+Ops, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+theta, }
\item[{const int}]{\+\_\+num\+Ops, }
\item[{const {\bf Composed\+Field\+Cuda} $\ast$}]{\+\_\+comp\+Fields, }
\item[{const int}]{\+\_\+num\+Comp\+Fields}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_ad3f1a323ddd56e99eea0afe0d7fd42f0}{}\label{namespaceisgw_ad3f1a323ddd56e99eea0afe0d7fd42f0}


Function to launch C\+U\+DA Kernel to evaluate gradient of global field. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+output} & \+: Device pointer to the field output \\
\hline
{\em \+\_\+outputG} & \+: Device pointer to gradient output \\
\hline
{\em \+\_\+sample\+Point} & \+: Const device pointer to the sample points \\
\hline
{\em \+\_\+num\+Samples} & The number of samples \\
\hline
{\em \+\_\+texture\+Space} & \+: Const device pointer to the texture space transform matrices, transform world space to texture space \\
\hline
{\em \+\_\+rigid\+Transform} & \+: Const device pointer to the rigid bone transform matrices \\
\hline
{\em \+\_\+field\+Funcs} & \+: Const device pointer to an array of textures holding the individual field functions \\
\hline
{\em \+\_\+num\+Fields} & \+: The number of field function textures \\
\hline
{\em \+\_\+comp\+Ops} & \+: Device pointer to to composition operator 3D textures. \\
\hline
{\em \+\_\+theta} & \+: Device pointer to theta opening function 1D texture. \\
\hline
{\em \+\_\+num\+Ops} & \+: Number of composition operators. \\
\hline
{\em \+\_\+comp\+Fields} & \+: Device pointer to composed fields, a structure that holds ids for primitive fields and their composition operator \\
\hline
{\em \+\_\+num\+Comp\+Fields} & \+: Number of composed fields \\
\hline
\end{DoxyParams}
\index{isgw@{isgw}!Generate\+One\+Ring\+Centroid\+Weights@{Generate\+One\+Ring\+Centroid\+Weights}}
\index{Generate\+One\+Ring\+Centroid\+Weights@{Generate\+One\+Ring\+Centroid\+Weights}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{Generate\+One\+Ring\+Centroid\+Weights(glm\+::vec3 $\ast$\+\_\+verts, const glm\+::vec3 $\ast$\+\_\+normals, const int \+\_\+num\+Verts, float $\ast$\+\_\+centroid\+Weights, const int $\ast$\+\_\+one\+Ring\+Ids, const glm\+::vec3 $\ast$\+\_\+one\+Ring\+Verts, const int $\ast$\+\_\+num\+Neighs\+Per\+Vert, const int $\ast$\+\_\+one\+Ring\+Scatter\+Addr)}{GenerateOneRingCentroidWeights(glm::vec3 *_verts, const glm::vec3 *_normals, const int _numVerts, float *_centroidWeights, const int *_oneRingIds, const glm::vec3 *_oneRingVerts, const int *_numNeighsPerVert, const int *_oneRingScatterAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void isgw\+::\+Generate\+One\+Ring\+Centroid\+Weights (
\begin{DoxyParamCaption}
\item[{glm\+::vec3 $\ast$}]{\+\_\+verts, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+normals, }
\item[{const int}]{\+\_\+num\+Verts, }
\item[{float $\ast$}]{\+\_\+centroid\+Weights, }
\item[{const int $\ast$}]{\+\_\+one\+Ring\+Ids, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+one\+Ring\+Verts, }
\item[{const int $\ast$}]{\+\_\+num\+Neighs\+Per\+Vert, }
\item[{const int $\ast$}]{\+\_\+one\+Ring\+Scatter\+Addr}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_a89743f193a8a8203e343479029570309}{}\label{namespaceisgw_a89743f193a8a8203e343479029570309}


Method to generate the one ring centroid weights for each mesh vertex using Mean Value Coordinates method. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+verts} & \+: Device pointer to vertices \\
\hline
{\em \+\_\+normals} & \+: Device pointer to normals \\
\hline
{\em \+\_\+num\+Verts} & \+: Numbe rof vertices \\
\hline
{\em \+\_\+centroid\+Weights} & \+: Device pointer to one ring centroid weights calculated using M\+VC. \\
\hline
{\em \+\_\+one\+Ring\+Verts} & \+: Device pointer to flat array of vertex ids of each vertices one ring nighbour. \\
\hline
{\em \+\_\+num\+Neighs\+Per\+Vert} & \+: Device pointer to array holding number of neighbours per vertex. \\
\hline
{\em \+\_\+neigh\+Scatter\+Addr} & \+: Device pointer holding start index into \+\_\+one\+Ring\+Verts for each vertex. \\
\hline
\end{DoxyParams}
\index{isgw@{isgw}!i\+Div\+Up@{i\+Div\+Up}}
\index{i\+Div\+Up@{i\+Div\+Up}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{i\+Div\+Up(uint a, uint b)}{iDivUp(uint a, uint b)}}]{\setlength{\rightskip}{0pt plus 5cm}uint isgw\+::i\+Div\+Up (
\begin{DoxyParamCaption}
\item[{uint}]{a, }
\item[{uint}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_a2e4ac5beae0fbbe25749f7ba5a85805e}{}\label{namespaceisgw_a2e4ac5beae0fbbe25749f7ba5a85805e}


Function to divide a by b and add 1 if there is a remainder, useful for generatinig the number of C\+U\+DA blocks from size of data and number of threads. 


\begin{DoxyParams}{Parameters}
{\em a} & \+: unsigned integer numerator \\
\hline
{\em b} & \+: unsigned integer denominator \\
\hline
\end{DoxyParams}
\index{isgw@{isgw}!Linear\+Blend\+Weight\+Skin@{Linear\+Blend\+Weight\+Skin}}
\index{Linear\+Blend\+Weight\+Skin@{Linear\+Blend\+Weight\+Skin}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{Linear\+Blend\+Weight\+Skin(glm\+::vec3 $\ast$\+\_\+deformed\+Vert, const glm\+::vec3 $\ast$\+\_\+orig\+Vert, glm\+::vec3 $\ast$\+\_\+deformed\+Norms, const glm\+::vec3 $\ast$\+\_\+orig\+Norms, const glm\+::mat4 $\ast$\+\_\+transform, const uint $\ast$\+\_\+bone\+Id, const float $\ast$\+\_\+weight, const int \+\_\+num\+Verts, const int \+\_\+num\+Bones)}{LinearBlendWeightSkin(glm::vec3 *_deformedVert, const glm::vec3 *_origVert, glm::vec3 *_deformedNorms, const glm::vec3 *_origNorms, const glm::mat4 *_transform, const uint *_boneId, const float *_weight, const int _numVerts, const int _numBones)}}]{\setlength{\rightskip}{0pt plus 5cm}void isgw\+::\+Linear\+Blend\+Weight\+Skin (
\begin{DoxyParamCaption}
\item[{glm\+::vec3 $\ast$}]{\+\_\+deformed\+Vert, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+orig\+Vert, }
\item[{glm\+::vec3 $\ast$}]{\+\_\+deformed\+Norms, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+orig\+Norms, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+transform, }
\item[{const uint $\ast$}]{\+\_\+bone\+Id, }
\item[{const float $\ast$}]{\+\_\+weight, }
\item[{const int}]{\+\_\+num\+Verts, }
\item[{const int}]{\+\_\+num\+Bones}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_a9f9396298bae07477376b8fa48795327}{}\label{namespaceisgw_a9f9396298bae07477376b8fa48795327}


Function to launch C\+U\+DA Kernel to perform linear blend weight skinning. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+deformed\+Vert} & \+: Device pointer to the deformed vertices, this is the pointer that is mapped to the vertex buffer object \\
\hline
{\em \+\_\+orig\+Vert} & \+: Const device pointer to the original mesh vertices \\
\hline
{\em \+\_\+deformed\+Norms} & \+: Device pointer to the deformed normals, this is the pointer that is mapped to the normal buffer object \\
\hline
{\em \+\_\+orig\+Norms} & \+: Const device pointer to the original mesh normals \\
\hline
{\em \+\_\+transforms} & \+: Const device pointer to the bone transforms \\
\hline
{\em \+\_\+bone\+Id} & \+: const device pointer to the vertex bone I\+Ds \\
\hline
{\em \+\_\+weights} & \+: const device pointer to the vertex bone weights \\
\hline
{\em \+\_\+num\+Verts} & \+: The number of vertices in the mesh \\
\hline
{\em \+\_\+num\+Bones} & \+: The number of bones \\
\hline
\end{DoxyParams}
\index{isgw@{isgw}!Simple\+Implicit\+Skin@{Simple\+Implicit\+Skin}}
\index{Simple\+Implicit\+Skin@{Simple\+Implicit\+Skin}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{Simple\+Implicit\+Skin(glm\+::vec3 $\ast$\+\_\+deformed\+Vert, const glm\+::vec3 $\ast$\+\_\+normal, const float $\ast$\+\_\+orig\+Iso\+Value, glm\+::vec3 $\ast$\+\_\+prev\+Iso\+Grad, const int \+\_\+num\+Verts, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const Composed\+Field\+Cuda $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields, const int $\ast$\+\_\+one\+Ring\+Verts, const float $\ast$\+\_\+centroid\+Weights, const int $\ast$\+\_\+neigh\+Scatter\+Addr, const float \+\_\+sigma, const float \+\_\+contact\+Angle, const int \+\_\+iterations)}{SimpleImplicitSkin(glm::vec3 *_deformedVert, const glm::vec3 *_normal, const float *_origIsoValue, glm::vec3 *_prevIsoGrad, const int _numVerts, const glm::mat4 *_textureSpace, const glm::mat4 *_rigidTransforms, const cudaTextureObject_t *_fieldFuncs, const int _numFields, const cudaTextureObject_t *_compOps, const cudaTextureObject_t *_theta, const int _numOps, const ComposedFieldCuda *_compFields, const int _numCompFields, const int *_oneRingVerts, const float *_centroidWeights, const int *_neighScatterAddr, const float _sigma, const float _contactAngle, const int _iterations)}}]{\setlength{\rightskip}{0pt plus 5cm}void isgw\+::\+Simple\+Implicit\+Skin (
\begin{DoxyParamCaption}
\item[{glm\+::vec3 $\ast$}]{\+\_\+deformed\+Vert, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+normal, }
\item[{const float $\ast$}]{\+\_\+orig\+Iso\+Value, }
\item[{glm\+::vec3 $\ast$}]{\+\_\+prev\+Iso\+Grad, }
\item[{const int}]{\+\_\+num\+Verts, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+texture\+Space, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+rigid\+Transforms, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+field\+Funcs, }
\item[{const int}]{\+\_\+num\+Fields, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+comp\+Ops, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+theta, }
\item[{const int}]{\+\_\+num\+Ops, }
\item[{const {\bf Composed\+Field\+Cuda} $\ast$}]{\+\_\+comp\+Fields, }
\item[{const int}]{\+\_\+num\+Comp\+Fields, }
\item[{const int $\ast$}]{\+\_\+one\+Ring\+Verts, }
\item[{const float $\ast$}]{\+\_\+centroid\+Weights, }
\item[{const int $\ast$}]{\+\_\+neigh\+Scatter\+Addr, }
\item[{const float}]{\+\_\+sigma, }
\item[{const float}]{\+\_\+contact\+Angle, }
\item[{const int}]{\+\_\+iterations}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_acd11ec618e357fefdc8e530211339cdf}{}\label{namespaceisgw_acd11ec618e357fefdc8e530211339cdf}


Function to launch C\+U\+DA Kernel to perform implicit skinning. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+deformed\+Vert} & \+: Device pointer to the deformed vertices, this is the pointer that is mapped to the vertex buffer object \\
\hline
{\em \+\_\+normal} & \+: Device pointer to the deformed normals, this is the pointer that is mapped to the normals buffer object \\
\hline
{\em \+\_\+orig\+Iso\+Value} & \+: Device pointer to iso values of each vertex in their original rest position. \\
\hline
{\em \+\_\+prev\+Iso\+Grad} & \+: Device pointer to the gradient of the field for each vertex from the previous frame. \\
\hline
{\em \+\_\+num\+Verts} & number of vertices. \\
\hline
{\em \+\_\+texture\+Space} & \+: Device pointer to the texture space transformation required to transform the sample space into normalise texture space \\
\hline
{\em \+\_\+rigid\+Transforms} & \+: Device pointer to the inverse bone transforms, required to transform sample space before sampling transformed fields. \\
\hline
{\em \+\_\+field\+Funcs} & \+: Device pointer to field function 3D textures. \\
\hline
{\em \+\_\+num\+Fields} & \+: Number of primitive fields. \\
\hline
{\em \+\_\+comp\+Ops} & \+: Device pointer to to composition operator 3D textures. \\
\hline
{\em \+\_\+theta} & \+: Device pointer to theta opening function 1D texture. \\
\hline
{\em \+\_\+num\+Ops} & \+: Number of composition operators. \\
\hline
{\em \+\_\+comp\+Fields} & \+: Device pointer to composed fields, a structure that holds ids for primitive fields and their composition operator \\
\hline
{\em \+\_\+num\+Comp\+Fields} & \+: Number of composed fields \\
\hline
{\em \+\_\+one\+Ring\+Verts} & \+: Device pointer to flat array of vertex ids of each vertices one ring nighbour. \\
\hline
{\em \+\_\+centroid\+Weights} & \+: Device pointer to one ring centroid weights calculated using M\+VC. \\
\hline
{\em \+\_\+neigh\+Scatter\+Addr} & \+: Device pointer holding start index into \+\_\+one\+Ring\+Verts for each vertex. \\
\hline
{\em \+\_\+sigma} & \+: scaling value for vertex projection step. \\
\hline
{\em \+\_\+contact\+Angle} & \+: threshold for running vertex projection step \\
\hline
{\em \+\_\+iterations} & \+: max number of iterations of vertex projection and tengential relaxations. \\
\hline
\end{DoxyParams}
