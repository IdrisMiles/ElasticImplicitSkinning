\hypertarget{namespaceisgw}{}\section{isgw Namespace Reference}
\label{namespaceisgw}\index{isgw@{isgw}}


, Implicit Skin G\+PU Wrapper (isgw), wraps up Implicit Skinining C\+U\+DA kernals in a C\+PP interface  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint \hyperlink{namespaceisgw_a2e4ac5beae0fbbe25749f7ba5a85805e}{i\+Div\+Up} (uint a, uint b)
\begin{DoxyCompactList}\small\item\em Function to divide a by b and add 1 if there is a remainder, useful for generatinig the number of C\+U\+DA blocks from size of data and number of threads. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_a9f9396298bae07477376b8fa48795327}{Linear\+Blend\+Weight\+Skin} (glm\+::vec3 $\ast$\+\_\+deformed\+Vert, const glm\+::vec3 $\ast$\+\_\+orig\+Vert, glm\+::vec3 $\ast$\+\_\+deformed\+Norms, const glm\+::vec3 $\ast$\+\_\+orig\+Norms, const glm\+::mat4 $\ast$\+\_\+transform, const uint $\ast$\+\_\+bone\+Id, const float $\ast$\+\_\+weight, const int \+\_\+num\+Verts, const int \+\_\+num\+Bones)
\begin{DoxyCompactList}\small\item\em Function to launch C\+U\+DA Kernel to perform linear blend weight skinning. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_acd11ec618e357fefdc8e530211339cdf}{Simple\+Implicit\+Skin} (glm\+::vec3 $\ast$\+\_\+deformed\+Vert, const glm\+::vec3 $\ast$\+\_\+normal, const float $\ast$\+\_\+orig\+Iso\+Value, glm\+::vec3 $\ast$\+\_\+prev\+Iso\+Grad, const int \+\_\+num\+Verts, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const \hyperlink{classComposedFieldCuda}{Composed\+Field\+Cuda} $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields, const int $\ast$\+\_\+one\+Ring\+Verts, const float $\ast$\+\_\+centroid\+Weights, const int $\ast$\+\_\+neigh\+Scatter\+Addr, const float \+\_\+sigma, const float \+\_\+contact\+Angle, const int \+\_\+iterations)\hypertarget{namespaceisgw_acd11ec618e357fefdc8e530211339cdf}{}\label{namespaceisgw_acd11ec618e357fefdc8e530211339cdf}

\begin{DoxyCompactList}\small\item\em Function to launch C\+U\+DA Kernel to perform implicit skinning. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_a8eed7cf9e253eaf6b3e9651fdc3deb28}{Eval\+Global\+Field} (float $\ast$\+\_\+output, const glm\+::vec3 $\ast$\+\_\+sample\+Point, const int \+\_\+num\+Samples, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const \hyperlink{classComposedFieldCuda}{Composed\+Field\+Cuda} $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields)
\begin{DoxyCompactList}\small\item\em Function to launch C\+U\+DA Kernel to evaluate the global field. \end{DoxyCompactList}\item 
void {\bfseries Eval\+Grad\+Global\+Field} (float $\ast$\+\_\+output, glm\+::vec3 $\ast$\+\_\+outputG, const glm\+::vec3 $\ast$\+\_\+sample\+Point, const int \+\_\+num\+Samples, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const \hyperlink{classComposedFieldCuda}{Composed\+Field\+Cuda} $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields)\hypertarget{namespaceisgw_ad3f1a323ddd56e99eea0afe0d7fd42f0}{}\label{namespaceisgw_ad3f1a323ddd56e99eea0afe0d7fd42f0}

\item 
void \hyperlink{namespaceisgw_a267fc0628a2245c86afb303701f45ddc}{Generate\+Scatter\+Address} (int $\ast$begin, int $\ast$end, int $\ast$scattered\+Addr)\hypertarget{namespaceisgw_a267fc0628a2245c86afb303701f45ddc}{}\label{namespaceisgw_a267fc0628a2245c86afb303701f45ddc}

\begin{DoxyCompactList}\small\item\em Method to generate scatter address. \end{DoxyCompactList}\item 
void \hyperlink{namespaceisgw_ae85bec13c1619427c06ad2e99b2e6d3b}{Generate\+One\+Ring\+Centroid\+Weights} (glm\+::vec3 $\ast$d\+\_\+verts, const glm\+::vec3 $\ast$d\+\_\+normals, const int \+\_\+num\+Verts, float $\ast$\+\_\+centroid\+Weights, const int $\ast$\+\_\+one\+Ring\+Ids, const glm\+::vec3 $\ast$\+\_\+one\+Ring\+Verts, const int $\ast$\+\_\+num\+Neighs\+Per\+Vert, const int $\ast$\+\_\+one\+Ring\+Scatter\+Addr)\hypertarget{namespaceisgw_ae85bec13c1619427c06ad2e99b2e6d3b}{}\label{namespaceisgw_ae85bec13c1619427c06ad2e99b2e6d3b}

\begin{DoxyCompactList}\small\item\em Method to generate the one ring centroid weights for each mesh vertex. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
, Implicit Skin G\+PU Wrapper (isgw), wraps up Implicit Skinining C\+U\+DA kernals in a C\+PP interface 

\begin{DoxyAuthor}{Author}
Idris Miles 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0  18/04/2017 
\end{DoxyVersion}


\subsection{Function Documentation}
\index{isgw@{isgw}!Eval\+Global\+Field@{Eval\+Global\+Field}}
\index{Eval\+Global\+Field@{Eval\+Global\+Field}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{Eval\+Global\+Field(float $\ast$\+\_\+output, const glm\+::vec3 $\ast$\+\_\+sample\+Point, const int \+\_\+num\+Samples, const glm\+::mat4 $\ast$\+\_\+texture\+Space, const glm\+::mat4 $\ast$\+\_\+rigid\+Transforms, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+field\+Funcs, const int \+\_\+num\+Fields, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+comp\+Ops, const cuda\+Texture\+Object\+\_\+t $\ast$\+\_\+theta, const int \+\_\+num\+Ops, const Composed\+Field\+Cuda $\ast$\+\_\+comp\+Fields, const int \+\_\+num\+Comp\+Fields)}{EvalGlobalField(float *_output, const glm::vec3 *_samplePoint, const int _numSamples, const glm::mat4 *_textureSpace, const glm::mat4 *_rigidTransforms, const cudaTextureObject_t *_fieldFuncs, const int _numFields, const cudaTextureObject_t *_compOps, const cudaTextureObject_t *_theta, const int _numOps, const ComposedFieldCuda *_compFields, const int _numCompFields)}}]{\setlength{\rightskip}{0pt plus 5cm}void isgw\+::\+Eval\+Global\+Field (
\begin{DoxyParamCaption}
\item[{float $\ast$}]{\+\_\+output, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+sample\+Point, }
\item[{const int}]{\+\_\+num\+Samples, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+texture\+Space, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+rigid\+Transforms, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+field\+Funcs, }
\item[{const int}]{\+\_\+num\+Fields, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+comp\+Ops, }
\item[{const cuda\+Texture\+Object\+\_\+t $\ast$}]{\+\_\+theta, }
\item[{const int}]{\+\_\+num\+Ops, }
\item[{const {\bf Composed\+Field\+Cuda} $\ast$}]{\+\_\+comp\+Fields, }
\item[{const int}]{\+\_\+num\+Comp\+Fields}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_a8eed7cf9e253eaf6b3e9651fdc3deb28}{}\label{namespaceisgw_a8eed7cf9e253eaf6b3e9651fdc3deb28}


Function to launch C\+U\+DA Kernel to evaluate the global field. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+output} & \+: Device pointer to the output \\
\hline
{\em \+\_\+sample\+Point} & \+: Const device pointer to the sample points \\
\hline
{\em \+\_\+num\+Samples} & The number of samples \\
\hline
{\em \+\_\+texture\+Space} & \+: Const device pointer to the texture space transform matrices, transform world space to texture space \\
\hline
{\em \+\_\+rigid\+Transform} & \+: Const device pointer to the rigid bone transform matrices \\
\hline
{\em \+\_\+field\+Funcs} & \+: Const device pointer to an array of textures holding the individual field functions \\
\hline
{\em \+\_\+num\+Fields} & \+: The number of field function textures \\
\hline
\end{DoxyParams}
\index{isgw@{isgw}!i\+Div\+Up@{i\+Div\+Up}}
\index{i\+Div\+Up@{i\+Div\+Up}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{i\+Div\+Up(uint a, uint b)}{iDivUp(uint a, uint b)}}]{\setlength{\rightskip}{0pt plus 5cm}uint isgw\+::i\+Div\+Up (
\begin{DoxyParamCaption}
\item[{uint}]{a, }
\item[{uint}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_a2e4ac5beae0fbbe25749f7ba5a85805e}{}\label{namespaceisgw_a2e4ac5beae0fbbe25749f7ba5a85805e}


Function to divide a by b and add 1 if there is a remainder, useful for generatinig the number of C\+U\+DA blocks from size of data and number of threads. 


\begin{DoxyParams}{Parameters}
{\em a} & \+: unsigned integer numerator \\
\hline
{\em b} & \+: unsigned integer denominator \\
\hline
\end{DoxyParams}
\index{isgw@{isgw}!Linear\+Blend\+Weight\+Skin@{Linear\+Blend\+Weight\+Skin}}
\index{Linear\+Blend\+Weight\+Skin@{Linear\+Blend\+Weight\+Skin}!isgw@{isgw}}
\subsubsection[{\texorpdfstring{Linear\+Blend\+Weight\+Skin(glm\+::vec3 $\ast$\+\_\+deformed\+Vert, const glm\+::vec3 $\ast$\+\_\+orig\+Vert, glm\+::vec3 $\ast$\+\_\+deformed\+Norms, const glm\+::vec3 $\ast$\+\_\+orig\+Norms, const glm\+::mat4 $\ast$\+\_\+transform, const uint $\ast$\+\_\+bone\+Id, const float $\ast$\+\_\+weight, const int \+\_\+num\+Verts, const int \+\_\+num\+Bones)}{LinearBlendWeightSkin(glm::vec3 *_deformedVert, const glm::vec3 *_origVert, glm::vec3 *_deformedNorms, const glm::vec3 *_origNorms, const glm::mat4 *_transform, const uint *_boneId, const float *_weight, const int _numVerts, const int _numBones)}}]{\setlength{\rightskip}{0pt plus 5cm}void isgw\+::\+Linear\+Blend\+Weight\+Skin (
\begin{DoxyParamCaption}
\item[{glm\+::vec3 $\ast$}]{\+\_\+deformed\+Vert, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+orig\+Vert, }
\item[{glm\+::vec3 $\ast$}]{\+\_\+deformed\+Norms, }
\item[{const glm\+::vec3 $\ast$}]{\+\_\+orig\+Norms, }
\item[{const glm\+::mat4 $\ast$}]{\+\_\+transform, }
\item[{const uint $\ast$}]{\+\_\+bone\+Id, }
\item[{const float $\ast$}]{\+\_\+weight, }
\item[{const int}]{\+\_\+num\+Verts, }
\item[{const int}]{\+\_\+num\+Bones}
\end{DoxyParamCaption}
)}\hypertarget{namespaceisgw_a9f9396298bae07477376b8fa48795327}{}\label{namespaceisgw_a9f9396298bae07477376b8fa48795327}


Function to launch C\+U\+DA Kernel to perform linear blend weight skinning. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+deformed\+Vert} & \+: Device pointer to the deformed vertices, this is the pointer that is mapped to the vertex buffer object \\
\hline
{\em \+\_\+orig\+Vert} & \+: Const device pointer to the original mesh vertices \\
\hline
{\em \+\_\+deformed\+Norms} & \+: Device pointer to the deformed normals, this is the pointer that is mapped to the normal buffer object \\
\hline
{\em \+\_\+orig\+Norms} & \+: Const device pointer to the original mesh normals \\
\hline
{\em \+\_\+transforms} & \+: Const device pointer to the bone transforms \\
\hline
{\em \+\_\+bone\+Id} & \+: const device pointer to the vertex bone I\+Ds \\
\hline
{\em \+\_\+weights} & \+: const device pointer to the vertex bone weights \\
\hline
{\em \+\_\+num\+Verts} & \+: The number of vertices in the mesh \\
\hline
{\em \+\_\+num\+Bones} & \+: The number of bones \\
\hline
\end{DoxyParams}
